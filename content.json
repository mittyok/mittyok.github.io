[{"title":"Spring cloud stream binder rabbitmq","date":"2016-12-28T06:48:15.000Z","path":"2016/12/28/Spring cloud stream binder rabbitmq/","text":"依赖12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-stream-binder-rabbit&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-stream&lt;/artifactId&gt;&lt;/dependency&gt;","tags":[{"name":"rabbitmq","slug":"rabbitmq","permalink":"https://mittyok.github.io/tags/rabbitmq/"},{"name":"spring cloud stream","slug":"spring-cloud-stream","permalink":"https://mittyok.github.io/tags/spring-cloud-stream/"}]},{"title":"RabbitMQ性能及扩展性的提升-路由拓扑结构","date":"2016-12-28T06:48:15.000Z","path":"2016/12/28/RabbitMQ性能及扩展性的提升-路由拓扑结构/","text":"原文 为了实现系统的高伸缩性，我们需要设计一个合适的路由拓扑。我们需要考虑很多的细节，比如：消息实现环境中存在的问题及限制，性能策略等。","tags":[{"name":"rabbitmq","slug":"rabbitmq","permalink":"https://mittyok.github.io/tags/rabbitmq/"},{"name":"performance","slug":"performance","permalink":"https://mittyok.github.io/tags/performance/"},{"name":"routing","slug":"routing","permalink":"https://mittyok.github.io/tags/routing/"},{"name":"scalability","slug":"scalability","permalink":"https://mittyok.github.io/tags/scalability/"}]},{"title":"Resizing a VirtualBox Virtual Machine (Debian) hard disk with LVM","date":"2016-12-09T07:20:15.000Z","path":"2016/12/09/Resizing a VirtualBox Virtual Machine (Debian) hard disk with LVM/","text":"磁盘相关的一些命令 fdisk -l df Hard disk format: vmdk to vdi1VBoxManage clonehd disk.vmdk disk.vdi --format vdi Hard disk resize1vboxmanage modifyhd --resize 20000 ./New_VM.vdi Resize the partitionDownload Gparted.isoDownload GParted 启动时加载GParted.iso，就可以进行分区管理啦。。。 资料： 大家可以看下这里学习一下：LVM相关介绍)","tags":[{"name":"virtualbox","slug":"virtualbox","permalink":"https://mittyok.github.io/tags/virtualbox/"},{"name":"resize","slug":"resize","permalink":"https://mittyok.github.io/tags/resize/"},{"name":"hard disk","slug":"hard-disk","permalink":"https://mittyok.github.io/tags/hard-disk/"},{"name":"lvm","slug":"lvm","permalink":"https://mittyok.github.io/tags/lvm/"}]},{"title":"spring cloud dataflow 入门","date":"2016-12-02T02:35:15.000Z","path":"2016/12/02/spring-cloud-dataflow-入门/","text":"最初为什么选择Spring make j2ee easier loose-coupling through interfaces, dependency injection, aspect-oriented programming sought to make the entire java ecosystem easier security, various types of database, data integration, and now cloud-native microservices spring is headed now with regard to reactive programming. H21The development of H2 was started in May 2004, but it was first published on December 14th 2005. The main author of H2, Thomas Mueller, is also the original developer of Hypersonic SQL. In 2001, he joined PointBase Inc. where he wrote PointBase Micro, a commercial Java SQL database. At that point, he had to discontinue Hypersonic SQL. The HSQLDB Group was formed to continued to work on the Hypersonic SQL codebase. The name H2 stands for Hypersonic 2, however H2 does not share code with Hypersonic SQL or HSQLDB. H2 is built from scratch. Spring Cloud Task1Spring Cloud Task allows a user to develop and run short lived microservices using Spring Cloud and run them locally, in the cloud, even on Spring Cloud Data Flow. Just add @EnableTask and run your app as a Spring Boot app (single application context). Task Demo123456789101112131415161718192021@SpringBootApplication@EnableTaskpublic class SampleTask &#123; @Bean CommandLineRunner commandLineRunner() &#123; return new HelloWorldCommandLineRunner(); &#125; public static void main(String[] args) &#123; SpringApplication.run(SampleTask.class, args); &#125; private class HelloWorldCommandLineRunner implements CommandLineRunner &#123; @Override public void run(String... strings) throws Exception &#123; System.out.println(&quot;Hello World!&quot;); &#125; &#125;&#125; Spring Batch在一些特定的情况下，我们会有这样的需求，我们需要批量的执行一些业务操作。这些业务操作一般都有这样的特点： 涉及到的数据量较大 不需要人工干预 处理较为复杂 需要自动的处理 典型的操作如：日结或者月结的一些计算，通知等类似的场景。。。 典型的场景 周期性的批量处理 并行作业 基于消息驱动的业务处理 失败后支持手动或者定时重启的场景 一些步骤需要按顺序执行的 作业需要支持事务的情况 Concept1 Job = Many Steps1 Step = 1 REAT-PROCESS-WRITE or 1 Tasklet Job = {Step 1 -&gt; Step 2 -&gt; Step 3} ExampleExample code. Main Class123456789@EnableTask@EnableBatchProcessing@SpringBootApplicationpublic class BatchJobApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(BatchJobApplication.class, args); &#125;&#125; Job Configuration12345678910111213141516171819202122232425262728@Configurationpublic class JobConfiguration &#123; private static Log logger = LogFactory.getLog(JobConfiguration.class); @Autowired public JobBuilderFactory jobBuilderFactory; @Autowired public StepBuilderFactory stepBuilderFactory; @Bean public Job job() &#123; return jobBuilderFactory.get(&quot;job&quot;) .start(stepBuilderFactory.get(&quot;jobStep1&quot;) .tasklet(new Tasklet() &#123; @Override public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception &#123; logger.info(&quot;Job was run&quot;); return RepeatStatus.FINISHED; &#125; &#125;).build()).build(); &#125;&#125; Chunk-Oriented Processing1Chunk oriented processing refers to reading the data one at a time, and creating &apos;chunks&apos; that will be written out, within a transaction boundary. Spring Cloud DataflowTap","tags":[{"name":"spring cloud","slug":"spring-cloud","permalink":"https://mittyok.github.io/tags/spring-cloud/"},{"name":"dataflow","slug":"dataflow","permalink":"https://mittyok.github.io/tags/dataflow/"},{"name":"task","slug":"task","permalink":"https://mittyok.github.io/tags/task/"},{"name":"batch","slug":"batch","permalink":"https://mittyok.github.io/tags/batch/"},{"name":"job","slug":"job","permalink":"https://mittyok.github.io/tags/job/"}]},{"title":"Axon Framework 介绍","date":"2016-12-02T02:35:15.000Z","path":"2016/12/02/Axon_Framework_介绍/","text":"Axon Framework设计最初的想法，就是设计一个框架，能够帮助开发者解决应用的可扩展和可伸缩性，使开发者不用太关心太多的技术细节，而是把这些事情交由框架本身来关心。 背景历史随着时间的前行，我们发现，软件产品的需求，无论是功能性的还是非功能性的都在快速的增长。企业不再仅仅是通过宣传册来大力宣传业务，更希望他们的产品能够与业务与时俱进。这不仅仅意味着项目和代码可能会越来越复杂，更意味着软件的功能设计要不断的增加、改变甚至移除。最令人心烦的是，有时候表面上看起来非常容易实现的一个特性，却需要开发团队对整个应用拆分和理解。而且，当今的网络应用的目标都是能应对几十亿的潜在用户，这就使得可扩展性成为一个不可争辩的一个需求。 目前已经有很多的应用和框架在尝试解决应用的可扩展性问题，比如：GigaSpaces、Terracotta，但是这些框架有一个明显的问题，他们在尝试解决问题的同时，让开发者依然使用开发者熟悉的分层架构，在某些情况下，甚至限制和阻止开发者使用一个真正的域模型，强迫开发者将所有的业务逻辑放入业务层中。尽管这样做可以很快的搭建起一个应用，但是慢慢的会导致应用越来越复杂，开发越来越慢。 Greg Young第一次提到了Command Query Responsiblity Segregation (CQRS)模式，通过改变应用的架构来解决这些问题。CQRS并不通过层来划分业务，而是基于读或者写来划分业务。这就意味着执行写的组件和执行读的组件是完全分开的。这样做的一个很重要的原因是应用的读和写对技术的或者是非技术的需求是完全不同的。Command执行后，查询组件会使用特定的事件进行同步或者异步的更新操作。正是这种通过事件更新的机制使得应用在框架上更容易延伸和扩展，最终也会更利于维护。 Note：这里我们不会花大部分时间来讲CQRS，如果你想更多的了解CQRS，可以访问这里：www.axonframework.org，这里有一些背景介绍的一些链接。 可以看到，CQRS与我们当今主流的开发结构有很大的差距，自然就很难理解。对于开发者而言，学习使用这种架构走一些弯路就再正常不过了。这也正是Axon Framework诞生的初衷：帮助开发者轻松的事项CQRS模式，从而把更多的时间和精力花在实际业务上。","tags":[{"name":"axon framework","slug":"axon-framework","permalink":"https://mittyok.github.io/tags/axon-framework/"},{"name":"event sourcing","slug":"event-sourcing","permalink":"https://mittyok.github.io/tags/event-sourcing/"}]},{"title":"耳机煲机技巧","date":"2016-11-24T02:17:15.000Z","path":"2016/11/24/耳机煲机技巧/","text":"注意啦。。。 这个是和Sony耳机客服处要的煲机方式，不一定适合所有人，仅供大家参考。。。 煲机方法： 舒筋——使用正常听音强度三分之一的音量驱动耳机12小时； 通络——使用正常听音强度三分之二的音量驱动耳机12小时； 习武——使用正常听音强度驱动耳机72小时； 打擂——使用正常听音强度三分之四的音量驱动耳机24小时； 出道——进入正常使用阶段。正常音就是你耳朵听上去最舒服的音量 请参考以上煲机方法","tags":[{"name":"耳机","slug":"耳机","permalink":"https://mittyok.github.io/tags/耳机/"},{"name":"煲机","slug":"煲机","permalink":"https://mittyok.github.io/tags/煲机/"}]},{"title":"Schema-Generator-By-JPA","date":"2016-11-16T02:29:13.000Z","path":"2016/11/16/Schema-Generator-By-JPA/","text":"配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!-- /////// START JPA Schema Generator --&gt;&lt;plugin&gt; &lt;groupId&gt;io.github.divinespear&lt;/groupId&gt; &lt;artifactId&gt;jpa-schema-maven-plugin&lt;/artifactId&gt; &lt;version&gt;0.2.0&lt;/version&gt; &lt;executions&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;jdbcUrl&gt;这里配置jdbcurl&lt;/jdbcUrl&gt; &lt;jdbcUser&gt;数据库用户名&lt;/jdbcUser&gt; &lt;jdbcPassword&gt;数据库密码&lt;/jdbcPassword&gt; &lt;!-- 这里需要指定JPA的实现提供者 --&gt; &lt;vendor&gt;hibernate&lt;/vendor&gt; &lt;!--&lt;databaseAction&gt;create&lt;/databaseAction&gt;--&gt; &lt;scriptAction&gt;drop-and-create&lt;/scriptAction&gt; &lt;!--&lt;scriptAction&gt;$&#123;AAA&#125;&lt;/scriptAction&gt;--&gt; &lt;packageToScan&gt;指定要扫描实体的包路径&lt;/packageToScan&gt; &lt;properties&gt; &lt;hibernate.dialect&gt;org.hibernate.dialect.MySQL5Dialect&lt;/hibernate.dialect&gt; &lt;/properties&gt;&lt;/configuration&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.eclipse.persistence/eclipselink --&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.persistence&lt;/groupId&gt; &lt;artifactId&gt;eclipselink&lt;/artifactId&gt; &lt;version&gt;2.6.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt; &lt;version&gt;5.0.9.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt; &lt;version&gt;5.0.9.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate.javax.persistence&lt;/groupId&gt; &lt;artifactId&gt;hibernate-jpa-2.1-api&lt;/artifactId&gt; &lt;version&gt;1.0.0.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.39&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/plugin&gt;&lt;!-- JPA Schema Generator END ///////// --&gt; 相关配置可以参照：jpa-schema-plugin","tags":[{"name":"database","slug":"database","permalink":"https://mittyok.github.io/tags/database/"},{"name":"ddl","slug":"ddl","permalink":"https://mittyok.github.io/tags/ddl/"},{"name":"hebernate","slug":"hebernate","permalink":"https://mittyok.github.io/tags/hebernate/"},{"name":"eclipselink","slug":"eclipselink","permalink":"https://mittyok.github.io/tags/eclipselink/"},{"name":"jpa","slug":"jpa","permalink":"https://mittyok.github.io/tags/jpa/"}]},{"title":"Hazelcast_Jcache_Implementation","date":"2016-11-14T02:43:44.000Z","path":"2016/11/14/Hazelcast-Jcache-Implementation/","text":"加入JCache依赖12345&lt;dependency&gt; &lt;groupId&gt;javax.cache&lt;/groupId&gt; &lt;artifactId&gt;cache-api&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt;&lt;/dependency&gt; 加入Hazelcast依赖 If hazelcast-\\.jar is added to the classpath, Hazelcast can only be used as a server provider. If hazelcast-client-\\.jar is added to the classpath, default provider is the client one. If hazelcast-all-\\.jar is added to the classpath, default provider is again the client one.","tags":[{"name":"hazelcast","slug":"hazelcast","permalink":"https://mittyok.github.io/tags/hazelcast/"},{"name":"spring cloud","slug":"spring-cloud","permalink":"https://mittyok.github.io/tags/spring-cloud/"},{"name":"jcache","slug":"jcache","permalink":"https://mittyok.github.io/tags/jcache/"}]},{"title":"Spring Cloud -- Config","date":"2016-11-13T07:58:57.000Z","path":"2016/11/13/Spring-Cloud-Config/","text":"什么是Spring Cloud ConfigConfig主要是为了解决分布式应用中的配置管理问题。Spring Cloud Config对配置进行集中化管理，提供了Server端和Client端的解决方案。所有的应用和服务都可以通过Server端管理、访问自己的配置。而且，Server端的配置我们还可以通过版本管理工具管理起来。 为什么需要Config曾几何时，我们把配置直接硬编码到我们的代码中，中途我们发现，配置一遍，我们就要改代码，重新构建工程，重新部署。于是我们聪明了一些，把配置写到配置文件中，这样不用改代码了，不用重新构建工程，但是依然不是那么愉快，我们还是要重新部署应用来使新的配置生效。好吧，我姑且接受这个现实吧。。。 突然有一天，我们发现，为了应对日益增长的访问量，一不小心，一盒应用我们部署了很多实例。。。别太美，我们发现改配置的话好麻烦啊，因为每一个实例中对应的配置都要修改，重新打包，重启。。。 突然，背后一阵凉风。。。ʘ‿ʘ 多么希望能有一个统一的地方用来管理配置。。。暂时就这么点需求。 好吧，Spring Cloud Config来满足你。 简单搭建一个Config Server 打开SPRING INITIALIZR 添加了Config Server的依赖 点击：Generate Project 解压产生的项目，看一下项目结构： 编辑DemoApplication.java,划线的地方是新加入的 resources下加入：bootstrap.yml 配置config server使用本地配置提供服务，具体配置如下： resources下加入conf文件夹，建立application.yml文件，加入如下内容： 12application: name: mittyok-test 在目录下执行：./mvnw package 到target目录下面 执行命令java -jar demo-0.0.1-SNAPSHOT.jar我们等待着。。。看到上面这个输出，应该已经启动OK。 验证Config Server OK我们上面在conf中只放入了一个application.yml文件，这个文件的配置会默认对所有应用有效，我们看一下刚才我们的配置是否被Config Server读取： 访问：http://localhost:8080/application-defualt.yml如果能看到如下结果，说明Server已经启动成功啦： 搭建一个简单的Config ClientConfig监控有时候我们需要在修改配置后，相关的客户端要refresh，重新加载配置。这个时候，我们需要用到SpringCloud Bus, Bus负责将Config Server端的事件广播到对应的应用，使应用重新加载配置。 假设，我们我们通过rabbit作为消息中间件，bus的事件广播渠道，则Config Server端我们需要如下配置： pom.xml 1234567891011121314151617&lt;!-- 通过此消息中间件广播 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt; &lt;version&gt;1.0.2.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 事件总线，监听及处理cloud中的一些事件，如通过/monitor传入的操作 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-bus&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- 使服务暴露/monitor endpoint 以方便外部触发监听事件 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-monitor&lt;/artifactId&gt; &lt;version&gt;1.1.2.RELEASE&lt;/version&gt;&lt;/dependency&gt; bootstrap.yml 12345spring: rabbitmq: addresses: 192.168.99.100:5672 # rabbitmq地址 username: admin # 用户名 password: admin # 密码 Config Client端与服务端配置基本一致，但是不需要暴露/monitor endpoint 注意：两端的事件实体与Json的转换规则上一定要一致，不要出现客户端转化成的json使用hyphon格式（”-“），而服务端用camelcase的形式读取，类似这样的问题。 待续","tags":[{"name":"spring cloud","slug":"spring-cloud","permalink":"https://mittyok.github.io/tags/spring-cloud/"},{"name":"config server","slug":"config-server","permalink":"https://mittyok.github.io/tags/config-server/"},{"name":"config client","slug":"config-client","permalink":"https://mittyok.github.io/tags/config-client/"}]},{"title":"Log4jdbc-Guide","date":"2016-10-01T13:47:53.000Z","path":"2016/10/01/Log4jdbc-Guide/","text":"基于Springboot 1.4 配置依赖123456&lt;!-- https://mvnrepository.com/artifact/org.bgee.log4jdbc-log4j2/log4jdbc-log4j2 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.bgee.log4jdbc-log4j2&lt;/groupId&gt; &lt;artifactId&gt;log4jdbc-log4j2-jdbc4.1&lt;/artifactId&gt; &lt;version&gt;1.16&lt;/version&gt;&lt;/dependency&gt; 配置驱动1spring.datasource.driver-class-name: net.sf.log4jdbc.sql.jdbcapi.DriverSpy 配置Log探测器在classpath下建一个文件，命名为：log4jdbc.log4j2.properties。添加如下内容：1log4jdbc.spylogdelegator.name=net.sf.log4jdbc.log.slf4j.Slf4jSpyLogDelegator OK啦，启动吧，现在应该有效果了。 太详细的，大家再到网上看一下吧。。。 需要注意的一些日志配置Log4jdbc 用以下几个可以配置的日志种类：12345jdbc.sqlonly : 仅记录 SQLjdbc.sqltiming ：记录 SQL 以及耗时信息jdbc.audit ：记录除了 ResultSet 之外的所有 JDBC 调用信息，会产生大量的记录，有利于调试跟踪具体的 JDBC 问题jdbc.resultset ：会产生更多的记录信息，因为记录了 ResultSet 的信息jdbc.connection ：记录连接打开、关闭等信息，有利于调试数据库连接相关问题 配置形式可参考如下：12345log4j.logger.jdbc.sqlonly=OFFlog4j.logger.jdbc.sqltiming=INFOlog4j.logger.jdbc.audit=OFFlog4j.logger.jdbc.resultset=OFFlog4j.logger.jdbc.connection=OFF","tags":[{"name":"log4j","slug":"log4j","permalink":"https://mittyok.github.io/tags/log4j/"},{"name":"sql","slug":"sql","permalink":"https://mittyok.github.io/tags/sql/"},{"name":"tuning","slug":"tuning","permalink":"https://mittyok.github.io/tags/tuning/"},{"name":"springboot","slug":"springboot","permalink":"https://mittyok.github.io/tags/springboot/"}]},{"title":"jpa-schema-maven-plugin_guide","date":"2016-10-01T07:19:50.000Z","path":"2016/10/01/jpa-schema-maven-plugin-guide/","text":"配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!-- /////// START JPA Schema Generator --&gt;&lt;plugin&gt; &lt;groupId&gt;io.github.divinespear&lt;/groupId&gt; &lt;artifactId&gt;jpa-schema-maven-plugin&lt;/artifactId&gt; &lt;version&gt;0.2.0&lt;/version&gt; &lt;configuration&gt; &lt;jdbcUrl&gt;jdbc:mysql://192.168.99.100:3306/dawnorder&lt;/jdbcUrl&gt; &lt;jdbcUser&gt;root&lt;/jdbcUser&gt; &lt;jdbcPassword&gt;dawn12345678&lt;/jdbcPassword&gt; &lt;vendor&gt;hibernate&lt;/vendor&gt; &lt;!--&lt;databaseAction&gt;create&lt;/databaseAction&gt;--&gt; &lt;scriptAction&gt;drop-and-create&lt;/scriptAction&gt; &lt;!--&lt;scriptAction&gt;$&#123;AAA&#125;&lt;/scriptAction&gt;--&gt; &lt;packageToScan&gt;com.huobi.dawn.common.entity&lt;/packageToScan&gt; &lt;properties&gt; &lt;hibernate.dialect&gt;org.hibernate.dialect.MySQL5Dialect&lt;/hibernate.dialect&gt; &lt;/properties&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;/executions&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.eclipse.persistence/eclipselink --&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.persistence&lt;/groupId&gt; &lt;artifactId&gt;eclipselink&lt;/artifactId&gt; &lt;version&gt;2.6.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt; &lt;version&gt;5.0.9.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt; &lt;version&gt;5.0.9.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate.javax.persistence&lt;/groupId&gt; &lt;artifactId&gt;hibernate-jpa-2.1-api&lt;/artifactId&gt; &lt;version&gt;1.0.0.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.39&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/plugin&gt;&lt;!-- JPA Schema Generator END ///////// --&gt; 执行 mvn jpa-schema:generate","tags":[{"name":"ddl","slug":"ddl","permalink":"https://mittyok.github.io/tags/ddl/"},{"name":"maven","slug":"maven","permalink":"https://mittyok.github.io/tags/maven/"},{"name":"hibernate","slug":"hibernate","permalink":"https://mittyok.github.io/tags/hibernate/"},{"name":"schema","slug":"schema","permalink":"https://mittyok.github.io/tags/schema/"}]},{"title":"spring_cloud_introduction","date":"2016-09-24T08:04:17.000Z","path":"2016/09/24/spring-cloud-introduction/","text":"Spring Cloud是个什么鬼Spring Cloud？什么东西，其实没那么神秘。。。你可以把它理解为一个工具集，为我们开发者提供的一套工具集，以方便我们构建稳健的分布式系统。利用这个工具集，我们能够轻松的实现分布式系统实际中常用到的一些设计模式。 配置管理 服务注册与发现 断路器 智能路由 控制总线 全局锁 分布式会话管理 分布式集群状态管理 Spring Cloud是构建在Spring Boot的基础之上的。通过引入一大堆基于Spring Boot相关的依赖来为单独的一个应用提供对应的功能。我们可以利用Spring Cloud提供的基础实现快速体验一下，当然了，如果我们以后得心应手了，我们可以轻松的做出自己的解决方案，或者对默认方案做一些干预，以达到我们自己的目的。 愉快的开始吧先看一看这个POM文件：1234567891011121314151617181920212223242526&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.3.7.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Brixton.SR6&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 可以看到，我们只是依赖了一个“spring-cloud-dependencies”，其他的依赖都会在父依赖中体现，也就是在这里：12345&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.3.7.RELEASE&lt;/version&gt;&lt;/parent&gt; 这个例子中使用了config client和eureka。当然了，通过改变artifactId也可以轻松导入其他的功能依赖。我们这样做的方式目前来说是最推荐的，通过依赖管理的方式，我们可以避免遇到更多的坑。 有啥特性呢Spring Cloud针对分布式系统设计中典型的用例提供了非常漂亮的开箱即用实现。对于其他不常用的应用场景，Spring Cloud也提供了一些扩展机制，我们可以轻松的搞掉这些场景。 分布式/版本化的配置管理 服务的注册发现 路由 服务的端到端的调用 负载均衡 断路器 全局锁 分布式选举和集群状态管理 分布式消息 Spring Cloud是通过声明似的方式来获取功能的支持的。通常来说，我们只需要改变相关的依赖，并且加上相关的注解，就可以获取对应的功能。举例来说，在上面的依赖基础之上，我们定义一个具有服务注册和发现特性的应用。1234567@SpringBootApplication@EnableDiscoveryClientpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; Spring Cloud中的主要项目Spring Cloud Config主要解决外部配置管理的问题。可以通过Git来提供配置源。所有的配置资源会直接映射为Spring的环境变量。所有的配置可以通过http的方式进行访问，所以，对于异构语言平台来说也是一个福音。可以从统一的地方获取配置信息。 Spring Cloud Netflix主要是为了方便与Netflix OSS的组件进行集成。比如说：Eureka，Hystrix，Zuul，Archaius等等。 Spring Cloud Bus提供了一个消息总线，用来为服务与服务实例之间进行分布式消息传递。当我们需要跨领域集群进行状态交互是非常有用的。比如说，如果配置中心配置发生变更后，会有变更事件通知给所有订阅配置服务的应用。这种变更事件就会通过事件总线来进行传输。 Spring Cloud for Cloud Foundry方便与Pivotal Cloudfoundry集成。集成了服务发现，也可以轻松的实现单点登录和OAuth2，可以创建一个Cloundfoundry的服务broker。 Spring Cloud Cloud Foundry Service Broker提供一个创建服务broker的切入点，服务broker可以管理可以托管于Cloud Foundry的服务。 Spring Cloud Cluster为Zookeeper，Redis，Hazelcast，Consul提供了分布式选举和通用的状态交互模式的实现。 Spring Cloud Consul提供了使用Hashicorp Consul实现的服务发现和配置管理。 Spring Cloud Security主要是安全实现，比如给客户端提供OAuth2的安全机制等。 Spring Cloud Sleuth主要用于分布式tracing，可以与Zipkin，Htrace，ELK一起工作。 Spring Cloud Data Flow用于服务编排的一个工具。 Spring Cloud Stream一个轻量级的事件驱动的微服务的框架。 Spring Cloud Stream App Starters主要用于与外部系统的集成。 Spring Cloud Task主要是为了设计一些生命周期较短的微服务，以方便执行一些有限的数据处理。 Spring Cloud Task App Starters主要是方便Task与应用集成。 Spring Cloud Zookeeper类似于Consul，只不过是基于Zookeeper的。 Spring Cloud for Amazon Web Services主要是为了方便Amazon Web Services集成。 Spring Cloud Connectors主要是为了方便PAAS平台连接后端的数据库或者消息broker。 Spring Cloud Starters主要是为了使依赖管理做起来更加的容易。 Spring Cloud CLI一套命令行工具，可以轻松的基于groovy语言创建一些服务。","tags":[{"name":"spring cloud","slug":"spring-cloud","permalink":"https://mittyok.github.io/tags/spring-cloud/"},{"name":"spring","slug":"spring","permalink":"https://mittyok.github.io/tags/spring/"},{"name":"spring boot","slug":"spring-boot","permalink":"https://mittyok.github.io/tags/spring-boot/"},{"name":"eureka","slug":"eureka","permalink":"https://mittyok.github.io/tags/eureka/"},{"name":"netflix","slug":"netflix","permalink":"https://mittyok.github.io/tags/netflix/"},{"name":"zuul","slug":"zuul","permalink":"https://mittyok.github.io/tags/zuul/"}]},{"title":"spring_cloud_introduction","date":"2016-09-24T08:04:17.000Z","path":"2016/09/24/spring-cloud-introduction的副本/","text":"Spring Cloud是个什么鬼Spring Cloud？什么东西，其实没那么神秘。。。你可以把它理解为一个工具集，为我们开发者提供的一套工具集，以方便我们构建稳健的分布式系统。利用这个工具集，我们能够轻松的实现分布式系统实际中常用到的一些设计模式。 配置管理 服务注册与发现 断路器 智能路由 控制总线 全局锁 分布式会话管理 分布式集群状态管理 Spring Cloud是构建在Spring Boot的基础之上的。通过引入一大堆基于Spring Boot相关的依赖来为单独的一个应用提供对应的功能。我们可以利用Spring Cloud提供的基础实现快速体验一下，当然了，如果我们以后得心应手了，我们可以轻松的做出自己的解决方案，或者对默认方案做一些干预，以达到我们自己的目的。 愉快的开始吧先看一看这个POM文件：1234567891011121314151617181920212223242526&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.3.7.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Brixton.SR6&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 可以看到，我们只是依赖了一个“spring-cloud-dependencies”，其他的依赖都会在父依赖中体现，也就是在这里：12345&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.3.7.RELEASE&lt;/version&gt;&lt;/parent&gt; 这个例子中使用了config client和eureka。当然了，通过改变artifactId也可以轻松导入其他的功能依赖。我们这样做的方式目前来说是最推荐的，通过依赖管理的方式，我们可以避免遇到更多的坑。 有啥特性呢Spring Cloud针对分布式系统设计中典型的用例提供了非常漂亮的开箱即用实现。对于其他不常用的应用场景，Spring Cloud也提供了一些扩展机制，我们可以轻松的搞掉这些场景。 分布式/版本化的配置管理 服务的注册发现 路由 服务的端到端的调用 负载均衡 断路器 全局锁 分布式选举和集群状态管理 分布式消息 Spring Cloud是通过声明似的方式来获取功能的支持的。通常来说，我们只需要改变相关的依赖，并且加上相关的注解，就可以获取对应的功能。举例来说，在上面的依赖基础之上，我们定义一个具有服务注册和发现特性的应用。1234567@SpringBootApplication@EnableDiscoveryClientpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; Spring Cloud中的主要项目Spring Cloud Config主要解决外部配置管理的问题。可以通过Git来提供配置源。所有的配置资源会直接映射为Spring的环境变量。所有的配置可以通过http的方式进行访问，所以，对于异构语言平台来说也是一个福音。可以从统一的地方获取配置信息。 Spring Cloud Netflix主要是为了方便与Netflix OSS的组件进行集成。比如说：Eureka，Hystrix，Zuul，Archaius等等。 Spring Cloud Bus提供了一个消息总线，用来为服务与服务实例之间进行分布式消息传递。当我们需要跨领域集群进行状态交互是非常有用的。比如说，如果配置中心配置发生变更后，会有变更事件通知给所有订阅配置服务的应用。这种变更事件就会通过事件总线来进行传输。 Spring Cloud for Cloud Foundry方便与Pivotal Cloudfoundry集成。集成了服务发现，也可以轻松的实现单点登录和OAuth2，可以创建一个Cloundfoundry的服务broker。 Spring Cloud Cloud Foundry Service Broker提供一个创建服务broker的切入点，服务broker可以管理可以托管于Cloud Foundry的服务。 Spring Cloud Cluster为Zookeeper，Redis，Hazelcast，Consul提供了分布式选举和通用的状态交互模式的实现。 Spring Cloud Consul提供了使用Hashicorp Consul实现的服务发现和配置管理。 Spring Cloud Security主要是安全实现，比如给客户端提供OAuth2的安全机制等。 Spring Cloud Sleuth主要用于分布式tracing，可以与Zipkin，Htrace，ELK一起工作。 Spring Cloud Data Flow用于服务编排的一个工具。 Spring Cloud Stream一个轻量级的事件驱动的微服务的框架。 Spring Cloud Stream App Starters主要用于与外部系统的集成。 Spring Cloud Task主要是为了设计一些生命周期较短的微服务，以方便执行一些有限的数据处理。 Spring Cloud Task App Starters主要是方便Task与应用集成。 Spring Cloud Zookeeper类似于Consul，只不过是基于Zookeeper的。 Spring Cloud for Amazon Web Services主要是为了方便Amazon Web Services集成。 Spring Cloud Connectors主要是为了方便PAAS平台连接后端的数据库或者消息broker。 Spring Cloud Starters主要是为了使依赖管理做起来更加的容易。 Spring Cloud CLI一套命令行工具，可以轻松的基于groovy语言创建一些服务。","tags":[{"name":"spring cloud","slug":"spring-cloud","permalink":"https://mittyok.github.io/tags/spring-cloud/"},{"name":"spring","slug":"spring","permalink":"https://mittyok.github.io/tags/spring/"},{"name":"spring boot","slug":"spring-boot","permalink":"https://mittyok.github.io/tags/spring-boot/"},{"name":"eureka","slug":"eureka","permalink":"https://mittyok.github.io/tags/eureka/"},{"name":"netflix","slug":"netflix","permalink":"https://mittyok.github.io/tags/netflix/"},{"name":"zuul","slug":"zuul","permalink":"https://mittyok.github.io/tags/zuul/"}]}]